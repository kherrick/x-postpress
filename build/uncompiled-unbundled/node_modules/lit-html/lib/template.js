export const marker=`{{lit-${(Math.random()+"").slice(2)}}}`;export const nodeMarker=`<!--${marker}-->`;export const markerRegex=new RegExp(`${marker}|${nodeMarker}`);export const boundAttributeSuffix="$lit$";export class Template{constructor(result,element){this.parts=[];this.element=element;let index=-1,partIndex=0;const nodesToRemove=[],_prepareTemplate=template=>{const content=template.content,walker=document.createTreeWalker(content,133,null,!1);let previousNode,currentNode;while(walker.nextNode()){index++;previousNode=currentNode;const node=currentNode=walker.currentNode;if(1===node.nodeType){if(node.hasAttributes()){const attributes=node.attributes;let count=0;for(let i=0;i<attributes.length;i++){if(0<=attributes[i].value.indexOf(marker)){count++}}while(0<count--){const stringForPart=result.strings[partIndex],name=lastAttributeNameRegex.exec(stringForPart)[2],attributeLookupName=name.toLowerCase()+boundAttributeSuffix,attributeValue=node.getAttribute(attributeLookupName),strings=attributeValue.split(markerRegex);this.parts.push({type:"attribute",index,name,strings});node.removeAttribute(attributeLookupName);partIndex+=strings.length-1}}if("TEMPLATE"===node.tagName){_prepareTemplate(node)}}else if(3===node.nodeType){const nodeValue=node.nodeValue;if(0>nodeValue.indexOf(marker)){continue}const parent=node.parentNode,strings=nodeValue.split(markerRegex),lastIndex=strings.length-1;partIndex+=lastIndex;for(let i=0;i<lastIndex;i++){parent.insertBefore(""===strings[i]?createMarker():document.createTextNode(strings[i]),node);this.parts.push({type:"node",index:index++})}parent.insertBefore(""===strings[lastIndex]?createMarker():document.createTextNode(strings[lastIndex]),node);nodesToRemove.push(node)}else if(8===node.nodeType){if(node.nodeValue===marker){const parent=node.parentNode,previousSibling=node.previousSibling;if(null===previousSibling||previousSibling!==previousNode||previousSibling.nodeType!==Node.TEXT_NODE){parent.insertBefore(createMarker(),node)}else{index--}this.parts.push({type:"node",index:index++});nodesToRemove.push(node);if(null===node.nextSibling){parent.insertBefore(createMarker(),node)}else{index--}currentNode=previousNode;partIndex++}else{let i=-1;while(-1!==(i=node.nodeValue.indexOf(marker,i+1))){this.parts.push({type:"node",index:-1})}}}}};_prepareTemplate(element);for(const n of nodesToRemove){n.parentNode.removeChild(n)}}}export const isTemplatePartActive=part=>-1!==part.index;export const createMarker=()=>document.createComment("");export const lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;