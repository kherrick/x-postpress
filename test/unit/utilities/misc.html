<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>misc</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="../../../node_modules/chai/chai.js"></script>
    <script src="../../../node_modules/mocha/mocha.js"></script>
    <script src="../../../node_modules/wct-mocha/wct-mocha.js"></script>
  </head>
  <body>
    <script type="module">
      import { buildQueryString, formatDate, removeSubdomain } from '../../../src/utilities/misc.js'

      describe('tests buildQueryString', () => {
        // before(() => {})

        // after(() => {})

        // beforeEach(() => {})

        // afterEach(() => {})

        const supportedQueryStringAttributes = ['categories', 'include', 'page', 'per_page', 'search', 'slug', 'tags']

        it('builds the query string with one supported attribute', () => {
          const expectedResult = '?include=22'
          const result = buildQueryString({
            apiHost: 'https://content.example.com',
            apiPath: '/wp-json/wp/v2',
            include: '22',
          }, supportedQueryStringAttributes)

          expect(result).equal(expectedResult)
        })

        it('builds the query string with more than one supported attribute', () => {
          const expectedResult = '?page=1&per_page=5&search=item'
          const result = buildQueryString({
            apiHost: 'https://content.example.com',
            apiPath: '/wp-json/wp/v2',
            page: '1',
            per_page: '5',
            search: 'item',
          }, supportedQueryStringAttributes)

          expect(result).equal(expectedResult)
        })

        it('returns empty string when there are no supported attributes', () => {
          const expectedResult = ''
          const result = buildQueryString({
            apiHost: 'https://content.example.com',
            apiPath: '/wp-json/wp/v2',
            include: '22',
          }, [])

          expect(result).equal(expectedResult)
        })

        it('returns empty string when the first argument does not contain supported attributes', () => {
          const expectedResult = ''
          const result = buildQueryString({}, supportedQueryStringAttributes)

          expect(result).equal(expectedResult)
        })
      })

      describe('tests formatDate', () => {
        it('returns the formatted date', () => {
          new Map([
            ['1970-01-01T00:00:00', 'Thursday, 01 January 1970'],
            ['1999-12-31T12:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T13:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T14:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T15:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T16:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T17:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T18:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T19:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T20:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T21:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T22:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T23:00:00', 'Friday, 31 December 1999'],
            ['1999-12-31T23:59:59', 'Friday, 31 December 1999'],
            ['2000-01-01T00:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T02:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T03:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T04:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T05:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T06:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T07:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T08:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T09:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T10:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T11:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T12:00:00', 'Saturday, 01 January 2000'],
            ['2000-01-01T01:00:00', 'Saturday, 01 January 2000']
          ]).forEach((expectedDate, dateString) => {
            expect(formatDate(dateString)).equal(expectedDate)
          })
        })
      })

      describe('tests remove subdomain', () => {
        it('removes the subdomain from the provided https link', () => {
          const fixture = 'https://content.example.com'
          const expectation = 'https://example.com'
          const subdomain = 'content'

          expect(removeSubdomain(fixture, subdomain)).equal(expectation)
        })

        it('removes the subdomain from the provided http link', () => {
          const fixture = 'http://another.domain.example.com'
          const expectation = 'http://domain.example.com'
          const subdomain = 'another'

          expect(removeSubdomain(fixture, subdomain)).equal(expectation)
        })

        it('does not remove the subdomain when the provided argument does not match', () => {
          const fixture = 'https://another.example.com'
          const expectation = 'https://another.example.com'
          const subdomain = 'example'

          expect(removeSubdomain(fixture, subdomain)).equal(expectation)
        })
      })
    </script>
  </body>
</html>
